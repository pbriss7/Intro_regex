<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.552">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pascal Brissette">

<title>Introduction aux expressions régulières</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Intro_regex_files/libs/clipboard/clipboard.min.js"></script>
<script src="Intro_regex_files/libs/quarto-html/quarto.js"></script>
<script src="Intro_regex_files/libs/quarto-html/popper.min.js"></script>
<script src="Intro_regex_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Intro_regex_files/libs/quarto-html/anchor.min.js"></script>
<link href="Intro_regex_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Intro_regex_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Intro_regex_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Intro_regex_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Intro_regex_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduction aux expressions régulières</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Auteur·rice</div>
    <div class="quarto-title-meta-contents">
             <p>Pascal Brissette </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Date de publication</div>
    <div class="quarto-title-meta-contents">
      <p class="date">20 septembre 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="le-couteau-suisse-des-chercheureuses-en-sciences-humaines" class="level1">
<h1>Le couteau suisse des chercheur·euse·s en sciences humaines</h1>
<p>Dans le bagage des chercheuses et chercheurs en sciences humaines et sociales, habitué·e·s à travailler avec des textes, les expressions régulières constituent un couteau suisse d’une grande utilité qui permettra de trouver, d’extraire, de filtrer ou de remplacer des mots ou expressions variées dans un ou plusieurs textes. L’atelier va permettre de se familiariser avec cet outil. Nous allons l’utiliser dans un environnement de programmation, mais vous pouvez également tirer profit de cet outil dans des logiciels de traitement de texte.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/regex101.jpg" class="img-fluid figure-img"></p>
<figcaption>Site regex101.com</figcaption>
</figure>
</div>
</section>
<section id="origine-et-utilité-des-expressions-régulières" class="level1">
<h1>Origine et utilité des expressions régulières</h1>
<p>Les expressions régulières sont issues des travaux de Stephen Cole Kleene (1909-1994), mathématicien américain contemporain d’Alan Turing, dans le domaine des mathématiques formelles, et plus exactement de la théorie des automates. Elles sont mises à profit dès les années 1960 dans le repérage de motifs dans des textes et ont été utilisés dans les langages de programmation et les systèmes d’exploitation.</p>
<p>Dans les études littéraires, les expressions régulières peuvent servir à extraire de textes littéraires des noms d’entités ou des expressions très précises, avec une ou plusieurs conditions. On peut également les utiliser pour corriger des textes comportant des erreurs (pensons à des textes qui ont été océrisés). Comme on le verra plus ci-dessous, on s’en sert couramment en conjonction avec des fonctions de recherche pour structurer l’information des textes et pour les traiter ensuite avec les outils des TAL. Elles sont la pierre angulaire de cette partie du travail que l’on appelle le “prétraitement”.</p>
</section>
<section id="exemple-de-prétraitement-avec-expressions-régulières" class="level1">
<h1>Exemple de prétraitement avec expressions régulières</h1>
<p>Dans l’exemple ci-dessous, on importe le roman <em>Maria Chapdelaine</em>, de Louis Hémon, du site Projet Gutenberg. Vous pouvez exécuter les lignes de code l’une après l’autre, et observer le résultat. Les expressions régulières sont utilisées à trois reprises, une première fois pour repérer les débuts de chapitres, une deuxième fois pour segmenter les chaînes de caractéres (tokenisation), une troisième fois pour compter les occurrences des noms des prétendants de Maria dans chacun des chapitres.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importation sous forme de tableau de données du texte de Maria Chapdelaine avec son identifiant unique. Si le fichier existe déjà dans le dossier "données", il sera simplement chargé dans l'environnement.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="sc">!</span><span class="fu">dir.exists</span>(<span class="st">"donnees"</span>)) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dir.create</span>(<span class="st">"donnees"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">file.exists</span>(<span class="st">"donnees/maria.RDS"</span>)) {</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  maria <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"donnees/maria.RDS"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  maria <span class="ot">&lt;-</span> <span class="fu">gutenberg_download</span>(<span class="dv">13525</span>, <span class="at">mirror =</span> <span class="st">"http://mirror.csclub.uwaterloo.ca/gutenberg/"</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">saveRDS</span>(maria, <span class="st">"donnees/maria.RDS"</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformation de l'encodage des chaînes de caractères du vecteur `text`</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>maria<span class="sc">$</span>text <span class="ot">&lt;-</span> <span class="fu">iconv</span>(maria<span class="sc">$</span>text, <span class="at">from =</span> <span class="st">"latin1"</span>, <span class="st">"utf8"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Élimination des lignes blanches</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>maria <span class="ot">&lt;-</span> maria[maria<span class="sc">$</span>text <span class="sc">!=</span> <span class="st">""</span>,]</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Élimination du péritexte</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>maria <span class="ot">&lt;-</span> maria[<span class="fu">grep</span>(<span class="st">"CHAPITRE I</span><span class="sc">\\</span><span class="st">b"</span>, maria<span class="sc">$</span>text)<span class="sc">:</span><span class="fu">nrow</span>(maria),]</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Repérage de la ligne correspondant à chaque début de chapitre</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>debut_chapitres_v <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">grepl</span>(<span class="st">"CHAPITRE"</span>, maria<span class="sc">$</span>text))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Utilisation du vecteur précédent pour indiquer la ligne correspondant à la fin de chaque chapitre</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>fin_chapitres_v <span class="ot">&lt;-</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">append</span>((debut_chapitres_v[<span class="sc">-</span><span class="dv">1</span>] <span class="sc">-</span> <span class="dv">1</span>), <span class="fu">length</span>(maria<span class="sc">$</span>text))</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Création d'une petite fonction permettant la séparation des mots d'une chaîne de caractères (tokénisation)</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>tokenisation_fun <span class="ot">&lt;-</span> </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">function</span>(texte, debut_chapitre, fin_chapitre) {</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>  texte_v <span class="ot">&lt;-</span> texte[<span class="fu">as.integer</span>(debut_chapitre)<span class="sc">:</span><span class="fu">as.integer</span>(fin_chapitre)]</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>  mots_l <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(texte_v, <span class="st">"</span><span class="sc">\\</span><span class="st">W"</span>)    <span class="co"># séparation de tous les mots</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>  mots_v <span class="ot">&lt;-</span> <span class="fu">unlist</span>(mots_l)              <span class="co"># transformation de l'objet liste en vecteur</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  mots_v <span class="ot">&lt;-</span> <span class="fu">tolower</span>(mots_v)             <span class="co"># Bas de casse</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>  mots_pleins_v <span class="ot">&lt;-</span> <span class="fu">which</span>(mots_v <span class="sc">!=</span> <span class="st">""</span>)  <span class="co"># Identificatioon des éléments vides</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>  mots_v <span class="ot">&lt;-</span> mots_v[mots_pleins_v]       <span class="co"># Élimination des éléments vides</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>  mots_v <span class="ot">&lt;-</span> mots_v[<span class="sc">-</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)]             <span class="co"># Élimination des noms de chapitre</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(mots_v)                        <span class="co"># Renvoi explicite de l'objet vecteur</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Création d'une liste vide dans laquelle on emmagasinera les mots de chacun des chapitres</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>mots_chapitres_l <span class="ot">&lt;-</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"list"</span>, <span class="at">length =</span> <span class="fu">length</span>(debut_chapitres_v))</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="co"># On remplit notre objet liste avec les mots de chacun des chapitre (à l'aide d'une structure de contrôle appelée "boucle for")</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(debut_chapitres_v)) {</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>  mots_chapitres_l[[i]] <span class="ot">&lt;-</span> <span class="fu">tokenisation_fun</span>(</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="at">texte =</span> maria<span class="sc">$</span>text,</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="at">debut_chapitre =</span> (debut_chapitres_v[i]),</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="at">fin_chapitre =</span> fin_chapitres_v[i]</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="co"># On crée un nouveau tableau de données comprenant une colonne pour les numéros de chapitres:</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df <span class="ot">&lt;-</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>(</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="at">chapitre =</span> <span class="fu">c</span>(</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>      <span class="st">"I"</span>,</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>      <span class="st">"II"</span>,</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>      <span class="st">"III"</span>,</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>      <span class="st">"IV"</span>,</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>      <span class="st">"V"</span>,</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>      <span class="st">"VI"</span>,</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>      <span class="st">"VII"</span>,</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>      <span class="st">"VIII"</span>,</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>      <span class="st">"IX"</span>,</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>      <span class="st">"X"</span>,</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>      <span class="st">"XI"</span>,</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>      <span class="st">"XII"</span>,</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>      <span class="st">"XIII"</span>,</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>      <span class="st">"XIV"</span>,</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>      <span class="st">"XV"</span>,</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>      <span class="st">"XVI"</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="co"># ... une colonne où seront rassemblés tous les mots sous forme de liste:</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df<span class="sc">$</span>mots <span class="ot">&lt;-</span> <span class="fu">sapply</span>(mots_chapitres_l, <span class="st">"["</span>)</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Et une colonne indiquant le nombre de mots de chaque chapitre</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df<span class="sc">$</span>longueur_chap <span class="ot">&lt;-</span> <span class="fu">sapply</span>(mots_chapitres_l, length)</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="co"># Création d'une colonne avec tous les mots de chaque chapitre distinct joints en une seule chaine de caractères</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df<span class="sc">$</span>texte <span class="ot">&lt;-</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sapply</span>(mots_chapitres_df<span class="sc">$</span>mots, paste, <span class="at">collapse =</span> <span class="st">" "</span>)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a><span class="co"># On crée trois colonnes, une pour chacun des prénoms des prétendants de Maria. La valeur correspond au nombre d'occurrences de chaque prénom dans chaque chapitre. La fonction utilisée, `str_count()`, est prise à l'extension stringr.</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df<span class="sc">$</span>francois <span class="ot">&lt;-</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_count</span>(mots_chapitres_df<span class="sc">$</span>texte, <span class="at">pattern =</span> <span class="st">"fran[cç]ois"</span>)</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df<span class="sc">$</span>lorenzo <span class="ot">&lt;-</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_count</span>(mots_chapitres_df<span class="sc">$</span>texte, <span class="at">pattern =</span> <span class="st">"lorenzo"</span>)</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df<span class="sc">$</span>eutrope <span class="ot">&lt;-</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_count</span>(mots_chapitres_df<span class="sc">$</span>texte, <span class="at">pattern =</span> <span class="st">"eutrope"</span>)</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a><span class="co"># On peut visualiser la structure de données</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>mots_chapitres_df</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
</section>
<section id="principes-et-opérateurs-de-base" class="level1">
<h1>Principes et opérateurs de base</h1>
<p>Les expressions régulières sont des séquences de caractères (lettres, ponctuations, symboles) qui forment des motifs permettant de trouver d’autres séquences de caractères dans des textes.</p>
<p>Définition proposée par ChatGPT:</p>
<blockquote class="blockquote">
<p>Une <strong>expression régulière</strong> (ou <strong>regex</strong>, pour “regular expression” en anglais) est une séquence de caractères qui définit un <strong>motif</strong> utilisé pour rechercher, correspondre ou manipuler des chaînes de caractères dans du texte. Autrement dit, c’est un outil puissant qui permet de spécifier des règles pour trouver des fragments de texte qui respectent certaines conditions. Les expressions régulières sont largement utilisées dans divers domaines comme la programmation, le traitement de texte, l’analyse de données et l’automatisation. (OpenAI, ChatGPT-4o, version 21 sept. 2024)</p>
</blockquote>
<p>Une expression régulière peut prendre la forme exacte d’un mot ou d’une expression en langage naturel. Par exemple, “Montréal” attrapera très exactement cette chaîne précise de caractères dans un texte, “Montréal”, mais il attrapera également “Montréalais”, “Montréalaise” et “Montréalaises”, à moins que vous n’ajoutiez une balise de fin de mot: “Montréal\\b”. Dans cette dernière expression, les deux barres diagonales indiquent au logiciel que “b” n’est pas à prendre comme la lettre “b” d’un mot, mais comme un opérateur, une balise de mot. Dans la plupart des langages de programmation, une seule barre est utilisée. Les deux barres sont spécifiques à R, où elles servent à “échapper” l’opérateur d’échappement lui-même…</p>
<p>Voici quelques-uns des symboles et opérateurs les plus communs:</p>
<table class="table">
<colgroup>
<col style="width: 2%">
<col style="width: 26%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Expression</th>
<th>Description</th>
<th>Éléments saisis et exemples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>a, b, c…</code></p>
<p><code>A, B, C…</code></p>
<p><code>1, 2, 3</code></p></td>
<td>L’expression saisit la lettre ou le chiffre tel qu’il est exprimé.</td>
<td><p>“a”, “b”, “c”,</p>
<p>“A”, “B”, “C”</p>
<p>“1”, “2”, “3”</p></td>
</tr>
<tr class="even">
<td><code>\\b</code></td>
<td>Balise de mot</td>
<td>L’expression <code>jour</code> attrapera aussi bien le mot “jour” que “au<strong>jour</strong>d’hui”, tandis que <code>\\bjour\\b</code>` n’attrapera que le mot “jour” au singulier, tout en minuscules.</td>
</tr>
<tr class="odd">
<td><code>\\w</code></td>
<td>N’importe quel caractère d’un mot</td>
<td><code>\\w</code> saisira une seule lettre, minuscule ou majuscule, d’une suite de lettres encadrées de blancs typographiques ou de ponctuations. Par exemple, <code>str_extract("Victor Hugo", "\\w")</code>, renverra seulement la première lettre du premier mot, “V”.</td>
</tr>
<tr class="even">
<td><code>\\s</code></td>
<td>Une espace (simple ou tabulation)</td>
<td><code>\\s</code> saisira une espace, une seule, à moins d’être suivi de l’opérateur <code>+</code>. Ainsi, <code>strsplit("Victor Hugo", "\\s")</code>, en base R, séparera le prénom et le nom et renverra une liste comprenant les deux éléments.</td>
</tr>
<tr class="odd">
<td><code>.</code></td>
<td>N’importe quel caractère (lettre, chiffre, ponctuation, espace simple), une seule fois.</td>
<td><code>\\bMontr.al\\b</code> saisirait le mot “Montréal”, “Montreal”, mais également “Montrial”, “Montr’al”, “Montr al”, etc. Très pratique pour attraper dans un texte des mots dont on soupçonne qu’ils pourraient avoir été orthographiés de différentes manières.</td>
</tr>
<tr class="even">
<td><code>\\.</code></td>
<td>Un point, tout simplement. Les deux barres transversales inversées annulent la fonction spéciale accordée autrement au point.</td>
<td>La fonction <code>str_replace_all``("Je mange une pomme","\\.", "!")</code> renverra “Je mange une pomme!”, mais <code>str_replace_all(``"Je mange une pomme",``".", "!")</code> renverra “!!!!!!!!!!!!!!!!!!!”</td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td>Cet opérateur est un quantifieur “paresseux” (<em>lazy quantifier</em>).</td>
<td>Opérateur très utile pour indiquer que, dans une expression, une lettre ou un symbole est facultatif, que l’on veut attraper un mot, peu importe qu’une certaine lettre soit ou non présente. Par exemple <code>\\bMontréalaise?\\b</code> saisira aussi bien “Montréalais” que “Montréalaise”. Le caractère <code>?</code> rend facultatif le “e” qui précède l’opérateur.</td>
</tr>
<tr class="even">
<td><code>\\?</code></td>
<td>Un point d’interrogation, tout simplement</td>
<td>Le point d’interrogation est ici “échappé” par les barres diagonales.</td>
</tr>
<tr class="odd">
<td><code>+</code></td>
<td>Cet opérateur est un quantifieur gourmand (<em>greedy quantifier</em>).</td>
<td><code>Ah+</code> saisira “Ah”, mais aussi “Ahh”, “Ahhh”, et ainsi de suite, jusqu’à ce que la fonction de recherche trouve un caractère autre que “h”.</td>
</tr>
<tr class="even">
<td><code>\\+</code></td>
<td>Un opérateur mathématique, tout simplement</td>
<td>Les barres diagonales “échappent” le symbole mathématique.</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>Marque le début d’une chaîne de caractères (ce qui suit doit se trouver au tout début de la chaîne).</td>
<td>Supposons que nous ayons 1000 documents à filtrer selon que le premier mot du document soit “Femme”. On pourra utiliser une fonction de recherche avec, comme motif, <code>^Femme</code>. Si le mot est présent dans l’un ou l’autre des documents, mais qu’il n’est pas le tout premier mot, le texte ne sera pas retenu.</td>
</tr>
<tr class="even">
<td><code>$</code></td>
<td>Marque la fin d’une chaîne de caractères (ce qui précède doit se trouver à la toute fin de la chaîne).</td>
<td>À l’inverse de l’exemple précédent, <code>femme$</code> saisira les documents qui se <strong>terminent</strong> par “femme” (sans la marque du pluriel: le “e” final de “femme” est immédiatement suivi du symbole <code>$</code>).</td>
</tr>
<tr class="odd">
<td><code>[ ]</code></td>
<td>Tout caractère, ponctuation ou symbole qui se trouve à l’intérieur, y compris l’espace ou la tabulation, une seule fois.</td>
<td>L’expression <code>Montr[ée]al</code> saisira à la fois “Montréal” et “Montreal”.</td>
</tr>
</tbody>
</table>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exemple simple d'une expression régulière qui repère et extrait tous les mots commençant par une majuscule. </span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>texte <span class="ot">&lt;-</span> <span class="st">"Victor Hugo, Emile Zola, et Jean-Paul Sartre sont des écrivains célèbres."</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">"</span><span class="sc">\\</span><span class="st">b[A-Z][a-z]+</span><span class="sc">\\</span><span class="st">b"</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(texte, pattern) <span class="sc">|&gt;</span> <span class="fu">unlist</span>()</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Victor" "Hugo"   "Emile"  "Zola"   "Jean"   "Paul"   "Sartre"</code></pre>
</div>
</div>
</section>
<section id="groupes-de-capture" class="level1">
<h1>Groupes de capture</h1>
<p>Il existe d’autres symboles et quantifieurs que vous découvrirez à l’usage, mais une introduction aux expressions régulières serait incomplète si elle ne comprenait également une présentation des groupes de capture (<em>group constructs</em>). Ces constructions permettent de regrouper des parties d’une expression régulière pour diverses opérations, comme la capture de sous-chaînes.</p>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 46%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Expression</th>
<th>Description</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>(?=motif)</code></td>
<td>Assertion d’anticipation (<em>positive lookahead</em>). Vérifie qu’un motif suit la chaine qu’on souhaite attraper.</td>
<td>Soit la phrase: “Simone de Beauvoir a écrit <em>Le Deuxième sexe</em> (1949). <em>Le Deuxième sexe</em> est un essai philosophique de de Beauvoir.”<br>
<br>
L’expression <code>Le Deuxième sexe(?=\\s\\(\\d{1,4}\\))</code> saisira la première occurrence du titre, mais non la seconde.</td>
</tr>
<tr class="even">
<td><code>(?&lt;=motif)</code></td>
<td>Assertion de rétrovision (<em>positive lookbehind</em>). Vérifie qu’un motif précède une chaine qu’on souhaite attraper.</td>
<td>Dans l’exemple précédent, l’expression <code>(?&lt;=Beauvoir a écrit )Le Deuxième sexe</code> attrapera la première occurrence du titre, mais non la seconde.</td>
</tr>
<tr class="odd">
<td><code>(?!motif)</code></td>
<td>Assertion d’anticipation négative (<em>negative lookahead</em>). Vérifie qu’un certain motif ne suit pas un autre motif qu’on souhaite attraper.</td>
<td><p>Soit la séquence suivante: “Victor Hugo est un écrivain. Victor s’intéresse aussi à la politique.”</p>
<p><br>
Le motif <code>Victor(?!\sHugo)</code> saisira la deuxième occurence de “Victor”, mais non la première.</p></td>
</tr>
<tr class="even">
<td><code>(?&lt;!motif)</code></td>
<td>Assertion de rétrovision négative (<em>negative lookbehind</em>). Vérifie qu’un certain motif ne précède pas un autre motif qu’on souhaite saisir.</td>
<td><p>Soit la séquence suivante: “Victor Hugo est un écrivain. Hugo s’intéresse aussi à la politique.”</p>
<p>Le motif <code>(?&lt;!Victor\s)Hugo</code> saisira la deuxième occurence de “Hugo”, mais non la première.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pratique" class="level1">
<h1>Pratique</h1>
<p>Le code ci-dessous permet d’extraire les 2000 premiers caractères du roman Maria Chapdelaine, importé et prétraité au début du document. Copier ce texte et coller-le dans la fenêtre d’un site permettant de tester les expressions régulières, tel <a href="https://regex101.com/">regex101</a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(mots_chapitres_df<span class="sc">$</span>texte[<span class="dv">1</span>], <span class="dv">1</span>, <span class="dv">2000</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "ite missa est la porte de l église de péribonka s ouvrit et les hommes commencèrent à sortir un instant plus tôt elle avait paru désolée cette église juchée au bord du chemin sur la berge haute au dessus de la rivière péribonka dont la nappe glacée et couverte de neige était toute pareille à une plaine la neige gisait épaisse sur le chemin aussi et sur les champs car le soleil d avril n envoyait entre les nuages gris que quelques rayons sans chaleur et les grandes pluies de printemps n étaient pas encore venues toute cette blancheur froide la petitesse de l église de bois et des quelques maisons de bois également espacées le long du chemin la lisière sombre de la forêt si proche qu elle semblait une menace tout parlait d une vie dure dans un pays austère mais voici que les hommes et les jeunes gens franchirent la porte de l église s assemblèrent en groupes sur le large perron et les salutations joviales les appels moqueurs lancés d un groupe à l autre l entrecroisement constant des propos sérieux ou gais témoignèrent de suite que ces hommes appartenaient à une race pétrie d invincible allégresse et que rien ne peut empêcher de rire cléophas pesant fils de thadée pesant le forgeron s enorgueillissait déjà d un habillement d été de couleur claire un habillement américain aux larges épaules matelassées seulement il avait gardé pour ce dimanche encore froid sa coiffure d hiver une casquette de drap noir aux oreillettes doublées en peau de lièvre au lieu du chapeau de feutre dur qu il eût aimé porter à côté de lui égide simard et d autres qui comme lui étaient venus de loin en traîneau agrafaient en sortant de l église leurs gros manteaux de fourrure qu ils serraient à la taille avec des écharpes rouges des jeunes gens du village très élégants dans leurs pelisses à col de loutre parlaient avec déférence au vieux nazaire larouche un grand homme gris aux larges épaules osseuses qui n avait rien changé pour la messe à sa tenue de tous les l ours vêtement court de toile brun"</code></pre>
</div>
</div>
<p>Fabriquez des expressions qui permettront de saisir:</p>
<ol type="1">
<li>Le déterminant “un”;</li>
<li>Le mot “église” non suivi de “de bois”.</li>
</ol>
</section>
<section id="utiliser-les-llm-génératifs-comme-assistant" class="level1">
<h1>Utiliser les LLM génératifs comme assistant</h1>
<p>Au cours de leur entraînement, les llm génératifs ont été exposés aux expressions régulières et ils peuvent donc servir d’assistants dans l’élaboration d’expressions ou dans l’explication d’expressions existantes. L’invite ci-dessous, formulée selon le modèle d’optimisation COSTAR, pourrait être adaptée à plusieurs cas de figure.</p>
<blockquote class="blockquote">
<p># CONTEXT</p>
<p>Tu es un expert dans la recherche d’information et l’extraction de chaines de caractères à l’aide d’expressions régulières (regex)</p>
<p># OBJECTIVE</p>
<p>Je souhaite que tu m’assistes dans l’élaboration d’expressions régulières. L’objectif est de remplacer toutes les occurrences du mot ‘église’ en ‘ÉGLISE’, à moins que ce mot soit écrit au pluriel.</p>
<p># STYLE</p>
<p>Le style doit être méthodique et pédagogique</p>
<p># TONE</p>
<p>Le ton doit être neutre et bienveillant</p>
<p># AUDIENCE</p>
<p>Tu assistes un spécialiste de littérature sans connaissance approfondie des expressions régulières.</p>
<p># RESPONSE</p>
<p>La réponse doit être fournie sous la forme d’une expression régulière dont chaque partie sera expliquée clairement. Le format est un texte suivi.</p>
</blockquote>
<p>Voici maintenant la réponse offerte à l’invite par GPT-4o. Elle présente un très bon point de départ pour exécuter l’opération.</p>
<blockquote class="blockquote">
<p>Pour atteindre ton objectif, nous allons élaborer une expression régulière (regex) qui permettra de remplacer le mot “église” par “ÉGLISE”, mais sans modifier les occurrences du mot lorsqu’il est au pluriel (“églises”).</p>
<p>Voici l’expression régulière que nous allons construire :</p>
<pre><code>\béglise\b(?!s)</code></pre>
<p>Maintenant, décomposons cette expression pour bien comprendre comment elle fonctionne :</p>
<ol type="1">
<li><p><strong><code>\b</code></strong> : Il s’agit d’une “limite de mot”. Cet élément permet de garantir que nous traitons uniquement des occurrences complètes du mot “église” et non des parties de mots plus grands. Par exemple, sans cette limite, un mot comme “réglisse” pourrait être partiellement modifié. La limite de mot assure que l’expression est appliquée uniquement à un mot isolé.</p>
<ul>
<li>Le premier <strong><code>\b</code></strong> avant “église” assure que le mot commence à cet endroit (et non au milieu d’un autre mot).</li>
<li>Le second <strong><code>\b</code></strong> après “église” assure que le mot se termine ici.</li>
</ul></li>
<li><p><strong><code>église</code></strong> : C’est simplement le mot que nous cherchons à modifier. L’expression va repérer chaque occurrence du mot “église” écrit au singulier ou au pluriel.</p></li>
<li><p><strong><code>(?!s)</code></strong> : Ceci est une “assertion négative”, appelée <strong>lookahead négatif</strong>. Cela signifie que l’expression ne correspondra pas si le mot “église” est immédiatement suivi d’un “s”. En d’autres termes, cela permet de s’assurer que nous ne sélectionnons que le mot “église” lorsqu’il n’est pas suivi par un “s”, ce qui exclut les formes plurielles.</p>
<ul>
<li><strong><code>?!</code></strong> signifie que l’expression vérifie ce qui suit “église” sans inclure ces caractères dans la sélection.</li>
<li><strong><code>s</code></strong> est le caractère que nous cherchons à éviter (le “s” du pluriel).</li>
</ul></li>
</ol>
<h3 id="exemple-dutilisation" class="anchored" data-anchor-id="utiliser-les-llm-génératifs-comme-assistant">Exemple d’utilisation</h3>
<ul>
<li><strong>Texte d’origine</strong> : “L’église du village et les églises de la ville sont anciennes.”</li>
<li><strong>Texte modifié</strong> : “L’ÉGLISE du village et les églises de la ville sont anciennes.”</li>
</ul>
<p>Dans cet exemple, la regex a remplacé “église” par “ÉGLISE” pour le mot singulier, mais a laissé “églises” (pluriel) intact.</p>
<h3 id="utilisation-pratique" class="anchored">Utilisation pratique</h3>
<p>Tu peux utiliser cette expression dans des outils ou langages de programmation qui supportent les expressions régulières (Python, R, Notepad++, etc.) pour effectuer ce remplacement de manière automatisée.</p>
<p>Si tu as des questions ou si tu veux explorer des variantes, n’hésite pas à demander !</p>
</blockquote>
<p>OpenAI, ChatGPT-4o, version du 21 septembre 2024.</p>
<p>Voyons maintenant comment cela pourrait être fait avec R:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>phrase_a_corriger <span class="ot">&lt;-</span> <span class="st">"Dans la petite ville, l’egliste se trouve en face de l’églize principale, qui, selon les habitants, est la plus ancienne eglise du quartier, bien que certains disent que l’eglise a été reconstruite plusieurs fois, car chaque eglise qu’ils ont connue était différente, ce qui rend l’histoire de l’eglisse assez mystérieuse pour ceux qui cherchent à comprendre comment l’egliste a pu résister à toutes ces années d’intempéries, malgré les rumeurs disant que l’eglize est en réalité bien plus récente que ce que les archives indiquent."</span> <span class="co">#(OpenAI, ChatGPT-4o, version du 21 septembre 2024.)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(phrase_a_corriger, <span class="at">pattern =</span> <span class="st">"</span><span class="sc">\\</span><span class="st">b[eé]gli</span><span class="sc">\\</span><span class="st">w+"</span>, <span class="at">replacement =</span> <span class="st">"église"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Dans la petite ville, l’église se trouve en face de l’église principale, qui, selon les habitants, est la plus ancienne église du quartier, bien que certains disent que l’église a été reconstruite plusieurs fois, car chaque église qu’ils ont connue était différente, ce qui rend l’histoire de l’église assez mystérieuse pour ceux qui cherchent à comprendre comment l’église a pu résister à toutes ces années d’intempéries, malgré les rumeurs disant que l’église est en réalité bien plus récente que ce que les archives indiquent."</code></pre>
</div>
</div>
</section>
<section id="bibliographie" class="level1">
<h1>Bibliographie</h1>
<p>Jockers, Matthew L. <em>Text Analysis with R for Students of Literature</em>. Quantitative Methods in the Humanities and Social Sciences. Springer International Publishing, 2014. <a href="https://doi.org/10.1007/978-3-319-03164-4" class="uri">https://doi.org/10.1007/978-3-319-03164-4</a>.</p>
<p>Hart, Michael S. «&nbsp;Gutenberg Project&nbsp;», https://www.gutenberg.org/. (Consulté le 21 septembre 2024.)</p>
<p>«&nbsp;Library Carpentry: Introduction to Working with Data (Regular Expressions): Regular Expressions&nbsp;». <a href="https://librarycarpentry.org/lc-data-intro/01-regular-expressions" class="uri">https://librarycarpentry.org/lc-data-intro/01-regular-expressions</a>. (Consulté le 20 septembre 2024.)</p>
<p>Taulli, Tom. <em>Regex with ChatGPT</em>. [First edition]. [Sebastopol, California]: O’Reilly Media, Inc., 2024. <a href="https://www.oreilly.com/library/view/-/0642572059316/." class="uri">https://www.oreilly.com/library/view/-/0642572059316/.</a></p>
<p>Yarberry, William. <em>CRAN Recipes : DPLYR, Stringr, Lubridate, and RegEx in R</em>. Berkeley, CA: Apress, 2021. <a href="https://doi.org/10.1007/978-1-4842-6876-6." class="uri">https://doi.org/10.1007/978-1-4842-6876-6.</a></p>
</section>
<section id="modules-r" class="level1">
<h1>Modules R:</h1>
<p>Johnston, Myfanwy, et David Robinson. gutenbergr: Download and Process Public Domain Works from Project Gutenberg. 0.2.4, 12 novembre 2023. R-Packages, https://cloud.r-project.org/web/packages/gutenbergr/index.html.</p>
<p>Wickham, Hadley, et al.&nbsp;stringr: Simple, Consistent Wrappers for Common String Operations. 1.5.1, 14 novembre 2023. R-Packages, https://cran.r-project.org/web/packages/stringr/index.html.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>